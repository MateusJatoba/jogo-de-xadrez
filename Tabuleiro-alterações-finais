package classes_pecas;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import funcoes_auxiliares.Arquivo;
import funcoes_auxiliares.sleep;

//Classe tabuleiro

	
public class Tabuleiro implements Arquivo{
	
	//Atributo adicional
	 private Casa[][] matriz;
	 private static int Q=0;
	 protected sleep sleep;
	 private int contadorMovimentosSemCaptura;
	 private List<String> historicoPosicoes;

	    // Variáveis para mudar a cor do background
	    final String ANSI_BLACK_BACKGROUND = "\u001B[40m"; 
	    final String ANSI_WHITE_BACKGROUND = "\u001B[47m"; 
	    final String ANSI_BLACK_TEXT = "\u001B[30m"; 
	    final String ANSI_WHITE_TEXT = "\u001B[37m"; 
	    final String ANSI_RESET = "\u001B[0m"; 

	    // Construtor criando os 64 espaços
	    public Tabuleiro() {
	        this.matriz = new Casa[8][8];
	        this.historicoPosicoes = new ArrayList<>();
	        this.contadorMovimentosSemCaptura = 0;
	    }

	    // Inicializando o tabuleiro e setando as coordenadas
	    public void inicializaTabuleiro() {
	        for (int i = 0; i < 8; i++) {
	            for (int j = 0; j < 8; j++) {
	                matriz[i][j] = new Casa();
	                matriz[i][j].setCoordenadaLinha(i);
	                matriz[i][j].setCoordenadaColuna(j);
	                matriz[i][j].setStatusoocupados(0);
	            }
	        }
	        System.out.println("Tabuleiro inicializado\n\n");
	    }

	    // Preenchendo o tabuleiro com peças dos jogadores
	    public void preencherTabuleiro(Jogador[] jogadores) {
	        for (int i = 0; i < jogadores.length; i++) {
	            Pecas[] pecasJogador = jogadores[i].getLista();
	            int linhaInicial = i == 0 ? 0 : 7;
	            int linhaPawns = i == 0 ? 1 : 6;

	            // Posicionar peças principais
	            setPeca(linhaInicial, 0, pecasJogador[10]);
	            setPeca(linhaInicial, 1, pecasJogador[12]);
	            setPeca(linhaInicial, 2, pecasJogador[8]);
	            setPeca(linhaInicial, 3, pecasJogador[15]);
	            setPeca(linhaInicial, 4, pecasJogador[14]);
	            setPeca(linhaInicial, 5, pecasJogador[9]);
	            setPeca(linhaInicial, 6, pecasJogador[13]);
	            setPeca(linhaInicial, 7, pecasJogador[11]);

	            // Posicionar peões
	            for (int j = 0; j < 8; j++) {
	                setPeca(linhaPawns, j, pecasJogador[j]);
	            }
	        }
	    }

	    // Imprimindo o tabuleiro
	    public void imprimirTabuleiro() {
	        int k = 1; // variável auxiliar

	        for (int i = 0; i < 8; i++) {
	            for (int j = 0; j < 8; j++) {
	                String background = (i + j) % 2 == 0 ? ANSI_WHITE_BACKGROUND : ANSI_BLACK_BACKGROUND;
	                String textColor = (i + j) % 2 == 0 ? ANSI_BLACK_TEXT : ANSI_WHITE_TEXT;
	                if (matriz[i][j].getStatusoocupados() == 0) {
	                    System.out.print(background + "     " + ANSI_RESET + "| ");
	                } else {
	                    Pecas peca = matriz[i][j].getPeca();
	                    String nomePeca = peca != null ? peca.getTipo().substring(0, 3) : "     ";
	                    System.out.print(background + textColor + " " + nomePeca + " " + ANSI_RESET + "| ");
	                }
	            }
	            System.out.println(k);
	            k++;
	            System.out.println("-------------------------------------------------------");
	        }
	        System.out.println("   A      B      C      D      E      F      G      H\n");
	    }

	    // Getters e Setters
	    public Casa[][] getMatriz() {
	        return matriz;
	    }

	    public void mudarCasa(int linhaFinal, int colunaFinal, Casa inicio) {
	        Pecas peca = inicio.getPeca();
	        inicio.setStatusoocupados(0);
	        setPeca(linhaFinal, colunaFinal, peca);
	    }

	    public void setPeca(int linha, int coluna, Pecas peca) {
	        matriz[linha][coluna].setPeca(peca);
	        matriz[linha][coluna].setStatusoocupados(1);
	    }

	    public void Jogar(Jogador[] jogadores) {
	        Scanner scanner = new Scanner(System.in);
	        int linha = 0, coluna = 0;
	        boolean casaValida = false;
	        Q++;
	        sleep.sleep_func(3000);
	        System.out.println("\n------------------------ RODADA " + Q + " ------------------------");
	        
	        for( int i = 0; i < jogadores.length; i++) {
	        	System.out.println("\nSua vez, " + jogadores[i].getNome() + "!");
	        	
	        	
	        	while (!casaValida) {
		            // Solicitar ao jogador as coordenadas da coluna
		            System.out.println("\nDigite a coordenada da coluna que deseja (A a H):");
		            String inputColuna = scanner.next().toUpperCase();
		            coluna = inputColuna.charAt(0) - 'A';

		            if (coluna >= 0 && coluna <= 7) {
		                // Solicitar ao jogador as coordenadas da linha
		                System.out.println("Digite a coordenada da linha que deseja (1 a 8):");
		                linha = scanner.nextInt() - 1;

		                if (linha >= 0 && linha <= 7) {
		                    Casa casa = matriz[linha][coluna];
		                    Pecas peca = casa.getPeca();

		                    if (casa.getStatusoocupados() == 1) {
		                        System.out.println("A peça na casa selecionada é: " + peca);

		                        List<int[]> possibilidades = peca.calcularPossibilidades(coluna, linha);
		                        System.out.println("Possibilidades de movimento:");
		                        int index = 1;
		                        for (int[] posicao : possibilidades) {
		                            int linhaPossibilidade = posicao[0];
		                            int colunaPossibilidade = posicao[1];
		                            if (matriz[linhaPossibilidade][colunaPossibilidade].getStatusoocupados() == 0) { 
		                                System.out.println(index + ". Linha: " + (linhaPossibilidade + 1) + ", Coluna: " + converterParaLetra(colunaPossibilidade));
		                                index++;
		                            }
		                        }

		                        if (index > 1) {
		                            System.out.println("Escolha uma das possibilidades de movimento (1 a " + (index - 1) + "):");
		                            int escolha = scanner.nextInt();

		                            if (escolha >= 1 && escolha < index) {
		                            	
		                                int novaLinha = possibilidades.get(escolha - 1)[0];
		                                int novaColuna = possibilidades.get(escolha - 1)[1];
		                                moverPeca(linha, coluna, novaLinha, novaColuna);
		                                casaValida = true;
		                                sleep.sleep_func(3000);
		                          
		                                imprimirTabuleiro();
		                                System.out.println("Status da casa: " + matriz[1][1].getStatusoocupados()); 
		                            } else {
		                                System.out.println("Escolha inválida. Por favor, escolha um número entre 1 e " + (index - 1) + ".");
		                            }
		                        } else {
		                            System.out.println("Não há movimentos possíveis para essa peça.");
		                        }
		                    } else {
		                        System.out.println("A casa selecionada está vazia. Por favor, escolha outra casa.");
		                    }
		                } else {
		                    System.out.println("Coordenada da linha inválida. Por favor, insira um número entre 1 e 8.");
		                }
		            } else {
		                System.out.println("Coordenada da coluna inválida. Por favor, insira uma letra entre A e H.");
		            }
		        }
	        	casaValida = false;
	        	
	        	/*VERIFICA SE HOUVE XEQUE MATE*/
	        	 if (xequeMate(jogadores, jogadores[i])) {
	                 System.out.println("\n------------------------ FIM DE JOGO ------------------------\n");
	                 System.out.println("Xeque-mate! O jogador " + jogadores[i].getNome() + " venceu!");
	                 break;
	                
	             }else {
	            	 if (verificarEmpate(jogadores, jogadores[i])) {
	                     System.out.println("\n------------------------ FIM DE JOGO ------------------------\n");
	                     System.out.println("O jogo terminou em empate!");
	                     break;
	                 }
	             }
	        	 /////////////////////////////////////////////////
	        	 
	        }  
	        
	        
	        
	        System.out.println("-------------------------------------------------------");
            System.out.println("RODADA ENCERRADA!!");
            System.out.println("-------------------------------------------------------");
            sleep.sleep_func(3000);
	    }
	    
	    
	    
	    ////////////////////////////////////////////////
	    
	    
	    public boolean estaSobAtaque(int linha, int coluna, Jogador[] jogadores) {
	        for (Jogador jogador : jogadores) {
	            Pecas[] pecasJogador = jogador.getLista();
	            for (Pecas peca : pecasJogador) {
	                List<int[]> possibilidades = peca.calcularPossibilidades(coluna, linha);
	                for (int[] posicao : possibilidades) {
	                    int linhaPossibilidade = posicao[0];
	                    int colunaPossibilidade = posicao[1];
	                    if (linhaPossibilidade == linha && colunaPossibilidade == coluna) {
	                        return true;
	                    }
	                }
	            }
	        }
	        return false;
	    }
	    
	    
	    ////////////////////// METODOS DO XEQUE MATE //////////////////////////////////////////////////
	    
	    public boolean isPeca(int linha, int coluna) {
	        return matriz[linha][coluna].getStatusoocupados() == 1;
	    }

	    private boolean xequeMate(Jogador[] jogadores, Jogador jogadorAtual) {
	        
	    	// procurar o rei p verificar se ha movimentaçoes disponiveis 
	    	Pecas rei = null;
	        for (Pecas peca : jogadorAtual.getLista()) {
	            if (peca.getTipo().equals("Rei")) {
	                rei = peca;
	                break;
	            }
	        }

	        Casa casaRei = encontrarCasaRei(jogadores, rei);
	        if (casaRei == null) {
	            return false; 
	        }

	        int linhaRei = casaRei.getCoordenadaLinha();
	        int colunaRei = casaRei.getCoordenadaColuna();
	        if (!estaSobAtaque(linhaRei, colunaRei, jogadores)) {
	            return false; 
	        }

	        //verifica se ha possibilidade de movimento
	        List<int[]> possibilidades = rei.calcularPossibilidades(colunaRei, linhaRei);
	        if (possibilidades.isEmpty()) {
	            return true;
	        }

	      
	        for (Jogador adversario : jogadores) {
	            if (adversario != jogadorAtual) {
	                for (Pecas peca : adversario.getLista()) {
	                    List<int[]> possibilidadesBloqueio = peca.calcularPossibilidades(colunaRei, linhaRei);
	                    for (int[] posicao : possibilidadesBloqueio) {
	                        int novaLinha = posicao[0];
	                        int novaColuna = posicao[1];
	                        if (!isPeca(novaLinha, novaColuna)) {
	                            
	                            Pecas pecaNaCasa = matriz[novaLinha][novaColuna].getPeca();
	                            matriz[novaLinha][novaColuna].setPeca(peca);
	                            matriz[linhaRei][colunaRei].setPeca(null);

	                            if (!estaSobAtaque(linhaRei, colunaRei, jogadores)) {
	                                
	                                matriz[linhaRei][colunaRei].setPeca(rei);
	                                matriz[novaLinha][novaColuna].setPeca(pecaNaCasa);
	                                return false;
	                            }

	                           
	                            matriz[linhaRei][colunaRei].setPeca(rei);
	                            matriz[novaLinha][novaColuna].setPeca(pecaNaCasa);
	                        }
	                    }
	                }
	            }
	        }

	        return true; 
	    }
	    
	    public boolean verificarEmpate(Jogador[] jogadores, Jogador jogadorAtual) {
	        // Verificar empate por afogamento
	        if (afogamento(jogadorAtual)) {
	            return true;
	        }

	        // Verificar empate por insuficiência de material
	        if (insuficienciaDeMaterial(jogadores)) {
	            return true;
	        }

	        // Verificar empate por regra dos 50 movimentos (essa lógica precisa ser implementada com contadores de movimentos)
	        if (regraDos50Movimentos()) {
	            return true;
	        }

	        // Verificar empate por repetição de posição (essa lógica precisa ser implementada com histórico de posições)
	        if (repeticaoDePosicao()) {
	            return true;
	        }

	        // Verificar se o jogador atual não tem mais movimentos possíveis
	        if (semMovimentosPossiveis(jogadorAtual, jogadores)) {
	            return true;
	        }

	        return false;
	    }

	    public boolean afogamento(Jogador jogador) {
	        for (Pecas peca : jogador.getLista()) {
	            if (peca != null && peca.getTipo().equals("Rei")) {
	                int linhaRei = peca.getPosicaoLinha();
	                int colunaRei = peca.getPosicaoColuna();
	                List<int[]> possibilidades = peca.calcularPossibilidades(colunaRei, linhaRei);

	                for (int[] posicao : possibilidades) {
	                    int novaLinha = posicao[0];
	                    int novaColuna = posicao[1];
	                    if (matriz[novaLinha][novaColuna].getStatusoocupados() == 0) {
	                        return false;
	                    }
	                }
	                break;
	            }
	        }
	        return true;
	    }

	    public boolean insuficienciaDeMaterial(Jogador[] jogadores) {
	        for (Jogador jogador : jogadores) {
	            Pecas[] pecasJogador = jogador.getLista();
	            boolean temPeca = false;

	            for (Pecas peca : pecasJogador) {
	                if (peca != null && !peca.getTipo().equals("Rei")) {
	                    temPeca = true;
	                    break;
	                }
	            }

	            if (!temPeca) {
	                return true;
	            }
	        }
	        return false;
	    }

	    public boolean regraDos50Movimentos() {
	        return contadorMovimentosSemCaptura >= 50;
	    }

	    public boolean repeticaoDePosicao() {
	        String estadoAtual = salvarEstadoAtual();
	        int repeticoes = 0;
	        for (String estado : historicoPosicoes) {
	            if (estado.equals(estadoAtual)) {
	                repeticoes++;
	            }
	        }
	        return repeticoes >= 3;
	    }

	    private boolean semMovimentosPossiveis(Jogador jogadorAtual, Jogador[] jogadores) {
	        boolean movimentoFeito = false;

	        for (Pecas peca : jogadorAtual.getLista()) {
	            int linhaOrigem = peca.getPosicaoLinha();
	            int colunaOrigem = peca.getPosicaoColuna();
	            List<int[]> possibilidades = peca.calcularPossibilidades(colunaOrigem, linhaOrigem);

	            for (int[] posicao : possibilidades) {
	                int novaLinha = posicao[0];
	                int novaColuna = posicao[1];
	                if (!isPeca(novaLinha, novaColuna)) {
	                    // Se houver ao menos uma possibilidade de movimento, não é um empate por falta de movimentos
	                    movimentoFeito = true;
	                    break;
	                }
	            }

	            if (movimentoFeito) {
	                break; // Se já encontramos um movimento possível, não precisamos verificar mais peças
	            }
	        }

	        return !movimentoFeito; // Se nenhum movimento é possível para nenhuma peça do jogador atual, é um empate
	    }

	    private Casa encontrarCasaRei(Jogador[] jogadores, Pecas rei) {
	        for (Jogador jogador : jogadores) {
	            for (Pecas peca : jogador.getLista()) {
	                if (peca.equals(rei)) {
	                    int linha = peca.getPosicaoLinha();
	                    int coluna = peca.getPosicaoColuna();
	                    return matriz[linha][coluna];
	                }
	            }
	        }
	        return null;
	    }

	    public void moverPecaComContagemEHistorico(int linhaOrigem, int colunaOrigem, int linhaDestino, int colunaDestino) {
	        Casa casaDestino = matriz[linhaDestino][colunaDestino];
	        boolean captura = casaDestino.getStatusoocupados() == 1;

	        moverPeca(linhaOrigem, colunaOrigem, linhaDestino, colunaDestino);

	        if (!captura) {
	            contadorMovimentosSemCaptura++;
	        } else {
	            contadorMovimentosSemCaptura = 0;
	        }

	        salvarEstadoAtual();
	    }
	    
	    private String salvarEstadoAtual() {
	        StringBuilder estadoAtual = new StringBuilder();
	        for (int i = 0; i < 8; i++) {
	            for (int j = 0; j < 8; j++) {
	                Pecas peca = matriz[i][j].getPeca();
	                if (peca != null) {
	                    estadoAtual.append(peca.getTipo().charAt(0));
	                } else {
	                    estadoAtual.append(" ");
	                }
	            }
	            estadoAtual.append("\n");
	        }
	        historicoPosicoes.add(estadoAtual.toString()); // Adicionar o estado atual ao histórico de posições
	        return estadoAtual.toString(); // Retornar o estado atual como uma string
	    }
	    
	    ///////////////////////////////////////////////
	    

	    private String converterParaLetra(int coluna) {
	        return Character.toString((char) ('A' + coluna));
	    }

	    private void moverPeca(int linhaOrigem, int colunaOrigem, int linhaDestino, int colunaDestino) {
	        Casa casaOrigem = matriz[linhaOrigem][colunaOrigem];
	        Casa casaDestino = matriz[linhaDestino][colunaDestino];

	        casaDestino.setPeca(casaOrigem.getPeca());
	        casaOrigem.setPeca(null);
	        casaOrigem.setStatusoocupados(0);
	        casaDestino.setStatusoocupados(1);
	    }
        
	}
